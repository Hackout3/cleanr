---
title: "Rules for field/column combinations"
author: "Edwin van Leeuwen, Marc Baguelin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r,include=F}
library(pander)
```

The package `cleanr` supports defining a set of rules that fields/columns need to conform to, e.g. the values in one column should always be higher than in another. The rules are defined can be read from a yaml file, or passed as a list. There are two types of rules supported 1) a required relation between fields (e.g. one field need to always be higher than the other and 2) accepted/valid and invalid combinations of values (e.g. the outcome of a disease needs to be death if a time of death is set).

Below follow some examples. All examples use an simulated set of epidemiological data (`epi.sim`)
```{r,echo=F}
library(cleanr)
data(epi.sim)
pander(head(epi.sim))
```

## Relation between columns

Relation rules are linking two columns with a rule that should be respected for all the pairs of values. To test if the rule is respected in a given dataset, the `rule_validation` function can be used with the rules inputed from a yaml file.

For example by using the rule.yaml file that contains the following rule:
```
- fields:
    - date.of.onset
    - date.of.hospitalisation
  relation: lte
```
we require that date.of.onset should always be lesser than or equal to date.of.hospitalisation.
```{r,eval=F}
rule_validation(epi.sim, rules.file="rule.yaml")
```
which passes for our data set. In contrast, if we require the date.of.onset to be strictly lesser than, by replacing `lte` with `lt` it will throw a warning and return `FALSE`:
```{r,echo=F}
  data(epi.sim)
  rule_validation(epi.sim, rules=list(list(
    "fields"=c("date.of.onset", "date.of.hospitalisation"), "relation"="lt" ) ) )
```

## (In)valid combinations of values

[in progress]

The combination set of rules define combinations of values between columns which are valid or invalid.  
For example by using the rule.yaml file that contains the following rule:
```
- fields:
    - gender
    - generation
  invalid: [f,0]
```

```{r,echo=F}
  data(epi.sim)
  rule_validation(epi.sim, rules=list(list(
    "fields"=c("gender", "generation"), "invalid"=c("f",0) ) ) )
```

Similarly if we specify `invalid: [f,100]` it does pass, because this combination does not occur in the data set.

You can also provide all the valid combinations by using `valid: [["f",1],["m",1], ...]`. Be aware that in this case you need to specify all the valid combinations and it will throw an error if the data contains any information that is not there.

## Conditional values in dataset

Conditional is more general version of valid/invalid although limited to two fields.

Ideas:
- I think conditionals should allow if (death=T then date.of.death !NA, or >... ).
    - This could be done by specifying the type of conditional? >, not, etc...
  
What we want to be able to express is 
```
if (field1 equal/greater_than/...) then
  field2 equal/lesser_than/not/...
```

```
- fields: [date.of.death, outcome]
  conditional:
    operator: ["not", "equal"]
    values: ["NA", "Death"]
```

Supported operater:

  - equal, ==
  - not, !=
  - gt, >, greater_than
  - lt, <, lesser_than
  - lte, <=, lesser_than_or_equal
  - gte, >=, greater_than_or_equal
  
[in progress]

Some values are imposed conditional of others in the dataset. For example if a patient is given a date of death, their status need to be "dead". A patient whose status in the dataset is "alive" while having a date of death should be flagged up for correction.

For example by using the rule.yaml file that contains the following rule:
```
- fields:
    - date.of.death
    - status
  conditional:[]
```

```{r,echo=F}
  data(epi.sim)
  rule_validation(epi.sim, rules=list(list(
    "fields"=c("date.of.onset", "date.of.hospitalisation"), "relation"="lt" ) ) )
```
